{"version":3,"file":"fieldUtils.js","sources":["../../../../admin/src/preview/utils/fieldUtils.ts"],"sourcesContent":["import { type FieldContentSourceMap } from '@strapi/admin/strapi-admin';\n\nimport type { PreviewContextValue } from '../pages/Preview';\nimport type { Modules, Schema, Struct, UID } from '@strapi/types';\n\ntype PathPart = { name: string; index?: number };\n\n// Helper function to parse path with array indices and return clean attribute names\nexport const parsePathWithIndices = (path: string): PathPart[] => {\n  // Split by dots, then parse array indices from each part. For example:\n  // input \"components.4.field.relations.2.name\"\n  // output [{name: \"components\", index: 4}, {name: \"field\"}, {name: \"relations\", index: 2}, {name: \"name\"}]\n  return path\n    .split('.')\n    .map((part) => {\n      const numericIndex = parseInt(part, 10);\n      if (!isNaN(numericIndex) && part === numericIndex.toString()) {\n        // This part is a pure numeric index, return it as an index for the previous part\n        return { name: '', index: numericIndex };\n      }\n      return { name: part };\n    })\n    .reduce((acc: PathPart[], part) => {\n      if (part.name === '' && part.index !== undefined) {\n        // This is an index, attach it to the previous part\n        if (acc.length > 0) {\n          acc[acc.length - 1].index = part.index;\n        }\n      } else {\n        acc.push(part);\n      }\n      return acc;\n    }, []);\n};\n\nexport function getAttributeSchemaFromPath({\n  path,\n  schema,\n  components,\n  document,\n}: {\n  path: string;\n  schema: PreviewContextValue['schema'] | PreviewContextValue['components'][string];\n  components: PreviewContextValue['components'];\n  document: Modules.Documents.AnyDocument;\n}): Schema.Attribute.AnyAttribute {\n  /**\n   * Create the function that will be recursively called.\n   * We don't do recursion on getAttributeSchemaFromPath itself because:\n   * - it takes a path string, not the parsed array that's better for recursion\n   * - even when several levels deep, we still need access to the root schema and components\n   */\n  const visitor = (\n    currentPathParts: PathPart[],\n    currentAttributes: Schema.Attributes,\n    currentData: any\n  ): Schema.Attribute.AnyAttribute => {\n    const [currentPart, ...remainingParts] = currentPathParts;\n\n    // Get the data and schema for the current path\n    const currentAttribute = currentAttributes[currentPart.name];\n\n    if (!currentAttribute) {\n      throw new Error('Invalid field path');\n    }\n\n    if (currentAttribute.type === 'relation') {\n      throw new Error('Relations not handled');\n    }\n\n    if (currentAttribute.type === 'component') {\n      const componentAttributes = components[currentAttribute.component].attributes;\n      if (currentAttribute.repeatable) {\n        // We must have the index, otherwise we don't know what data to use\n        if (currentPart.index === undefined) {\n          throw new Error('Invalid field path');\n        }\n        return visitor(\n          remainingParts,\n          componentAttributes,\n          currentData[currentPart.name][currentPart.index]\n        );\n      }\n\n      // Non repeatable component\n      return visitor(remainingParts, componentAttributes, currentData[currentPart.name]);\n    }\n\n    if (currentAttribute.type === 'dynamiczone') {\n      // We must have the index, otherwise we don't know what component we're dealing with\n      if (currentPart.index === undefined) {\n        throw new Error('Invalid field path');\n      }\n\n      const componentData = currentData[currentPart.name][currentPart.index];\n      const componentAttributes = components[componentData.__component].attributes;\n      return visitor(remainingParts, componentAttributes, componentData);\n    }\n\n    // Plain regular field. It ends the recursion\n    return currentAttributes[currentPart.name];\n  };\n\n  return visitor(parsePathWithIndices(path), schema.attributes, document);\n}\n\nexport function parseFieldMetaData(strapiSource: string): FieldContentSourceMap | null {\n  const searchParams = new URLSearchParams(strapiSource);\n  const path = searchParams.get('path');\n  const type = searchParams.get('type');\n  const documentId = searchParams.get('documentId');\n  const locale = searchParams.get('locale');\n  const model = searchParams.get('model');\n  const kind = searchParams.get('kind');\n\n  if (!path || !type || !documentId || !model) {\n    return null;\n  }\n\n  return {\n    path,\n    type: type as Schema.Attribute.AnyAttribute['type'],\n    documentId,\n    locale: locale ?? null,\n    model: model as UID.Schema | undefined,\n    kind: kind ? (kind as Struct.ContentTypeKind) : undefined,\n  };\n}\n"],"names":["parsePathWithIndices","path","split","map","part","numericIndex","parseInt","isNaN","toString","name","index","reduce","acc","undefined","length","push","getAttributeSchemaFromPath","schema","components","document","visitor","currentPathParts","currentAttributes","currentData","currentPart","remainingParts","currentAttribute","Error","type","componentAttributes","component","attributes","repeatable","componentData","__component","parseFieldMetaData","strapiSource","searchParams","URLSearchParams","get","documentId","locale","model","kind"],"mappings":"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"}